./minidash.py:def dashboard():
./minidash.py:def settings():
./minidash.py:def sweep():
./minidash.py:def restart():
./core/analysis.py:    def __init__(self, portfolio: Any = None):
./core/analysis.py:    def record_trade(self, symbol: str, profit_usd: Decimal, duration_seconds: float,
./core/analysis.py:    def get_stats(self) -> Dict[str, Any]:
./core/analysis.py:    def _calculate_sharpe_ratio(self, df: pd.DataFrame) -> float:
./core/analysis.py:    def _empty_stats(self) -> Dict[str, Any]:
./core/profit.py:def calculate_gross_profit(buy_price: Decimal, sell_price: Decimal, amount: Decimal) -> Decimal:
./core/profit.py:def apply_fees(gross: Decimal, fee_buy: Decimal, fee_sell: Decimal) -> Decimal:
./core/profit.py:def calculate_net_profit(
./core/profit.py:def estimate_slippage(order_book: Dict, trade_size: Decimal, side: str = 'buy') -> Decimal:
./core/health_monitor.py:    def __init__(self, portfolio: Portfolio, alert_callback: Callable, config, logger=None, market_registry=None):
./core/health_monitor.py:    def _load_config(self, config):
./core/health_monitor.py:    def _merge_configs(self, config: Dict) -> Dict:
./core/health_monitor.py:    def _setup_monitoring_logger(self):
./core/health_monitor.py:    def adjust_cycle_time(self, current_cycle_time: float, mode: str) -> float:
./core/health_monitor.py:    def _calculate_adaptive_sleep(self, current_cycle_time: float, mode: str) -> float:
./core/health_monitor.py:    def log_api_error(self, exchange_id: str, endpoint: str, error: str):
./core/health_monitor.py:    def log_api_success(self, exchange_id: str, endpoint: str, latency_ms: float):
./core/health_monitor.py:    def log_trade_execution(self, trade_details: Dict):
./core/health_monitor.py:    def log_network_latency(self, source: str, target: str, latency_ms: float):
./core/health_monitor.py:    def log_exchange_latency(self, exchange_id: str, latency_ms: float):
./core/health_monitor.py:    def log_rebalance_suggestion(self, suggestion: Dict):
./core/health_monitor.py:    def update_resource_usage(self):
./core/health_monitor.py:    def _calculate_error_rate(self, exchange_id: str) -> float:
./core/health_monitor.py:    def get_health_status(self) -> Dict[str, Any]:
./core/health_monitor.py:    def check_system_health(self):
./core/health_monitor.py:    def _perform_health_check(self) -> Dict[str, Any]:
./core/health_monitor.py:    def _generate_recommendations(self, health_status: Dict) -> List[str]:
./core/health_monitor.py:    def _get_active_alerts(self) -> List[Alert]:
./core/health_monitor.py:    def generate_report(self, report_type: str = "summary") -> Dict[str, Any]:
./core/health_monitor.py:    def _get_distribution(self) -> Dict[str, List[float]]:
./core/health_monitor.py:    def _get_aggregated_distribution(self) -> Dict[str, float]:
./core/health_monitor.py:    def save_report(self, filepath: str = "health_report.json"):
./core/health_monitor.py:    async def start(self):
./core/health_monitor.py:    def stop(self):
./core/health_monitor.py:    async def _check_all_systems(self):
./core/health_monitor.py:    async def _check_exchange_heartbeats(self):
./core/health_monitor.py:    async def _check_position_limits(self):
./core/health_monitor.py:    async def _check_daily_loss_limits(self):
./core/health_monitor.py:    async def _check_api_response_times(self):
./core/health_monitor.py:    def record_heartbeat(self, exchange_name: str, response_time_ms: int):
./core/health_monitor.py:    def record_error(self, exchange_name: str, error: str):
./core/auction.py:    def __init__(self):
./core/auction.py:    def analyze_order_book(self, bids: List[Tuple[Decimal, Decimal]],
./core/auction.py:    def limit_chase(book, side, size, max_slip=Decimal('0.02')):
./core/auction.py:    def auction_micro_timing(book, side):
./core/order_executor.py:    def __init__(self, config: Dict, logger: logging.Logger, exchanges: Dict, persistence_manager=None, fee_manager=None, risk_manager=None):
./core/order_executor.py:    async def execute_arbitrage(self, buy_exchange: str, sell_exchange: str, buy_price: Decimal, sell_price: Decimal,
./core/order_executor.py:    def _calculate_asset_amount(self, position_size_usd: Decimal, price: Decimal, base_currency: str) -> Decimal:
./core/order_executor.py:    def _get_amount_precision(self, currency: str) -> int:
./core/order_executor.py:    def _get_minimum_amount(self, currency: str) -> Decimal:
./core/order_executor.py:    def _validate_execution_params(self, buy_exchange: str, sell_exchange: str, buy_price: Decimal,
./core/order_executor.py:    async def _monitor_and_emergency_exit(self, original_buy_exchange: str, failed_sell_exchange: str, symbol: str,
./core/order_executor.py:    def _execute_order(self, exchange_id: str, symbol: str, side: str, amount: Decimal,
./utils/logger.py:    def __init__(self, name: str, component: str = None, log_level: str = "INFO"):
./utils/logger.py:    def _format_message(self, message: str, **kwargs) -> str:
./utils/logger.py:    def info(self, message: str, **kwargs):
./utils/logger.py:    def warning(self, message: str, **kwargs):
./utils/logger.py:    def error(self, message: str, **kwargs):
./utils/logger.py:    def critical(self, message: str, **kwargs):
./utils/logger.py:    def debug(self, message: str, **kwargs):
./utils/logger.py:    def trade(self, trade_data: Dict[str, Any]):
./utils/logger.py:    def performance(self, metrics: Dict[str, Any]):
./utils/logger.py:    def get_metrics(self) -> Dict[str, int]:
./utils/logger.py:    def reset_metrics(self):
./utils/logger.py:def setup_logger(name: str, log_level: str = "INFO", log_to_file: bool = True) -> logging.Logger:
./utils/logger.py:def get_logger(name: str) -> logging.Logger:
./dashboard.py:def initialize_exchanges():
./dashboard.py:def fetch_exchange_balances():
./dashboard.py:def fetch_realtime_prices():
./dashboard.py:def get_recent_trades(limit=50):
./dashboard.py:def get_bot_activity():
./dashboard.py:def calculate_arbitrage_opportunities(price_data):
./dashboard.py:def get_macro_rebalance_status(balance_data, price_data):
./dashboard.py:def create_asset_allocation_chart(asset_details):
./dashboard.py:def create_exchange_distribution_chart(balance_data, asset_type='BTC'):
./dashboard.py:def create_exchange_card(exchange_name, exchange_price, exchange_balance, fee_info):
./dashboard.py:def main():
./dashboard.py:        def color_profitable(val):
./adapters/exchanges/binanceus.py:    def __init__(self):
./adapters/exchanges/binanceus.py:    def get_name(self) -> str:
./adapters/exchanges/binanceus.py:    def get_balance(self, asset: str) -> Decimal:
./adapters/exchanges/binanceus.py:    def get_all_balances(self) -> Dict[str, Dict[str, Decimal]]:
./adapters/exchanges/binanceus.py:    def get_order_book(self, symbol: Symbol, limit: int = 5) -> Dict[str, List[Dict[str, Decimal]]]:
./adapters/exchanges/binanceus.py:    def get_ticker_price(self, symbol: Symbol) -> Price:
./adapters/exchanges/binanceus.py:    def place_order(self, symbol: Symbol, side: str, amount: Amount, price: Optional[Price] = None) -> Dict:
./adapters/exchanges/binanceus.py:    def fetch_fees(self) -> Dict[str, Any]:
./adapters/exchanges/binanceus.py:    def get_market_metadata(self) -> Dict[str, Any]:
./adapters/exchanges/binanceus.py:    def get_asset_metadata(self) -> Dict[str, Any]:
./adapters/exchanges/binanceus.py:    def fetch_deposit_address(self, asset: str, network: Optional[str] = None) -> Dict:
./adapters/exchanges/binanceus.py:    def withdraw(self, asset: str, amount: Decimal, address: str, network: str, params: Dict = None) -> Dict:
./adapters/exchanges/binanceus.py:    def cancel_order(self, order_id: str, symbol: Symbol) -> bool:
./adapters/exchanges/binanceus.py:    def get_supported_pairs(self) -> List[Symbol]:
./adapters/exchanges/binanceus.py:    def stake(self, asset: str, amount: Decimal) -> Dict:
./adapters/exchanges/binanceus.py:    def unstake(self, asset: str, amount: Decimal) -> Dict:
./adapters/exchanges/binanceus.py:    def get_staking_assets(self) -> List[Dict]:
./adapters/exchanges/kraken.py:    def __init__(self):
./adapters/exchanges/kraken.py:    def get_name(self) -> str:
./adapters/exchanges/kraken.py:    def get_balance(self, asset: str) -> Decimal:
./adapters/exchanges/kraken.py:    def get_all_balances(self) -> Dict[str, Dict[str, Decimal]]:
./adapters/exchanges/kraken.py:    def get_order_book(self, symbol: Symbol, limit: int = 5) -> Dict[str, List[Dict[str, Decimal]]]:
./adapters/exchanges/kraken.py:    def get_ticker_price(self, symbol: Symbol) -> Price:
./adapters/exchanges/kraken.py:    def fetch_fees(self) -> Dict[str, Any]:
./adapters/exchanges/kraken.py:    def get_market_metadata(self) -> Dict[str, Any]:
./adapters/exchanges/kraken.py:    def get_asset_metadata(self) -> Dict[str, Any]:
./adapters/exchanges/kraken.py:    def fetch_deposit_address(self, asset: str, method: str = 'Solana') -> Dict:
./adapters/exchanges/kraken.py:    def withdraw(self, asset: str, amount: Decimal, address: str, key: str) -> Dict:
./adapters/exchanges/kraken.py:    def place_order(self, symbol: Symbol, side: str, amount: Amount, price: Optional[Price] = None) -> Dict:
./adapters/exchanges/kraken.py:    def cancel_order(self, order_id: str, symbol: Symbol) -> bool:
./adapters/exchanges/kraken.py:    def get_supported_pairs(self) -> List[Symbol]:
./adapters/exchanges/kraken.py:    def stake(self, asset: str, amount: Decimal) -> Dict:
./adapters/exchanges/kraken.py:    def unstake(self, asset: str, amount: Decimal) -> Dict:
./adapters/exchanges/kraken.py:    def get_staking_assets(self) -> List[Dict]:
./adapters/exchanges/coinbase_advanced.py:    def _parse_pem_key(self, pem_key: str) -> str:
./adapters/exchanges/coinbase_advanced.py:    def __init__(self):
./adapters/exchanges/coinbase_advanced.py:    def get_name(self) -> str:
./adapters/exchanges/coinbase_advanced.py:    def fetch_fees(self) -> Dict[str, Any]:
./adapters/exchanges/coinbase_advanced.py:    def get_balance(self, asset: str) -> Decimal:
./adapters/exchanges/coinbase_advanced.py:    def get_all_balances(self) -> Dict[str, Dict[str, Decimal]]:
./adapters/exchanges/coinbase_advanced.py:    def get_order_book(self, symbol: Symbol, limit: int = 5) -> Dict[str, List[Dict[str, Decimal]]]:
./adapters/exchanges/coinbase_advanced.py:    def get_ticker_price(self, symbol: Symbol) -> Price:
./adapters/exchanges/coinbase_advanced.py:    def place_order(self, symbol: Symbol, side: str, amount: Amount, price: Optional[Price] = None) -> Dict:
./adapters/exchanges/coinbase_advanced.py:    def cancel_order(self, order_id: str, symbol: Symbol) -> bool:
./adapters/exchanges/coinbase_advanced.py:    def get_supported_pairs(self) -> List[Symbol]:
./adapters/exchanges/coinbase_advanced.py:    def get_market_metadata(self) -> Dict[str, Any]:
./adapters/exchanges/coinbase_advanced.py:    def get_asset_metadata(self) -> Dict[str, Any]:
./adapters/exchanges/coinbase_advanced.py:    def fetch_deposit_address(self, asset: str) -> Dict:
./adapters/exchanges/coinbase_advanced.py:    def withdraw(self, asset: str, amount: Decimal, address: str, network: str = 'base') -> Dict:
./adapters/exchanges/coinbase_advanced.py:    def stake(self, asset: str, amount: Decimal) -> Dict:
./adapters/exchanges/coinbase_advanced.py:    def unstake(self, asset: str, amount: Decimal) -> Dict:
./adapters/exchanges/coinbase_advanced.py:    def get_staking_assets(self) -> List[Dict]:
./adapters/exchanges/coinbase_regular.py:    def __init__(self):
./adapters/exchanges/coinbase_regular.py:    def get_name(self) -> str:
./adapters/exchanges/coinbase_regular.py:    def fetch_fees(self) -> Dict[str, Any]:
./adapters/exchanges/coinbase_regular.py:    def get_balance(self, asset: str) -> Decimal:
./adapters/exchanges/coinbase_regular.py:    def get_order_book(self, symbol: Symbol, limit: int = 5) -> Dict[str, List[Dict[str, Decimal]]]:
./adapters/exchanges/coinbase_regular.py:    def get_ticker_price(self, symbol: Symbol) -> Price:
./adapters/exchanges/coinbase_regular.py:    def place_order(self, symbol: Symbol, side: str, amount: Amount, price: Optional[Price] = None) -> Dict:
./adapters/exchanges/coinbase_regular.py:    def cancel_order(self, order_id: str, symbol: Symbol) -> bool:
./adapters/exchanges/coinbase_regular.py:    def stake(self, asset: str, amount: Decimal) -> Dict:
./adapters/exchanges/coinbase_regular.py:    def unstake(self, asset: str, amount: Decimal) -> Dict:
./adapters/exchanges/coinbase_regular.py:    def get_staking_assets(self) -> List[Dict]:
./adapters/data/feed.py:    def __init__(self, config: Dict, main_logger: logging.Logger, registry: Any = None):
./adapters/data/feed.py:    def set_latency_mode(self, mode: str):
./adapters/data/feed.py:    def get_total_balance_usd(self, exchange_name: str) -> float:
./adapters/data/feed.py:    def _get_btc_price_for_exchange(self, exchange_name: str) -> float:
./adapters/data/feed.py:    def subscribe(self, callback: Callable):
./adapters/data/feed.py:    async def _process_incoming_data(self, data: Dict):
./adapters/data/feed.py:    def update_market_context(self, symbol: str, exchange: str, bids: List, asks: List, last_price: float):
./adapters/data/feed.py:    def _update_market_phase(self, context: MarketContext):
./adapters/data/feed.py:    def _update_execution_confidence(self, context: MarketContext):
./adapters/data/feed.py:    async def start_websocket_feed(self):
./adapters/data/feed.py:    async def _init_custom_websockets(self):
./adapters/data/feed.py:    async def _handle_websocket_data(self, data: Dict):
./adapters/data/feed.py:    async def _monitor_websocket_health(self):
./adapters/data/feed.py:    async def _reconnect(self, name: str):
./adapters/data/feed.py:    async def _maintain_websocket_connections(self):
./adapters/data/ws.py:    def __init__(self, symbol: str = "btcusdt"):
./adapters/data/ws.py:    async def connect(self):
./adapters/data/ws.py:    async def _listen(self):
./adapters/data/ws.py:    async def _handle_message(self, data: dict):
./adapters/data/ws.py:    def subscribe(self, callback):
./adapters/data/ws.py:    async def _notify_callbacks(self, data: dict):
./adapters/data/ws.py:    def __init__(self, pair: str = "XBT/USD"):
./adapters/data/ws.py:    async def connect(self):
./adapters/data/ws.py:    async def _listen(self):
./adapters/data/ws.py:    def subscribe(self, callback):
./adapters/data/ws.py:    async def _notify_callbacks(self, data: dict):
./adapters/data/ws.py:    def __init__(self, product_ids: str = "BTC-USD"):
./adapters/data/ws.py:    async def connect(self):
./adapters/data/ws.py:    async def _listen(self):
./adapters/data/ws.py:    def subscribe(self, callback):
./adapters/data/ws.py:    async def _notify_callbacks(self, data: dict):
./adapters/data/ws.py:    def __init__(self, product_ids: str = "BTC-USD"):
./adapters/data/ws.py:    async def connect(self):
./adapters/data/ws.py:    async def _listen(self):
./adapters/data/ws.py:    def subscribe(self, callback):
./adapters/data/ws.py:    async def _notify_callbacks(self, data: dict):
./manager/signals.py:    def do_POST(self):
./manager/signals.py:    def log_message(self, fmt, *args):
./manager/signals.py:    def __init__(self, macro_callback: Callable, abot_callback: Optional[Callable] = None):
./manager/signals.py:    def _handle_signal(self, data: Dict):
./manager/signals.py:    def start(self):
./manager/signals.py:    def stop(self):
./manager/scanner.py:    def __post_init__(self):
./manager/scanner.py:    def __init__(self, primary_symbol: str = None, config: Dict = None, logger: logging.Logger = None):
./manager/scanner.py:    def to_dict(self) -> Dict:
./manager/scanner.py:    def update(self, new_context: Dict):
./manager/scanner.py:    def get_context(self) -> Dict:
./manager/scanner.py:    def get_spread(self, book: Dict) -> Decimal:
./manager/scanner.py:    def get_volatility(self, prices: List[Decimal]) -> Decimal:
./manager/scanner.py:    def get_cvd(self, book: Dict) -> Decimal:
./manager/scanner.py:    def get_book_imbalance(self, book: Dict) -> Decimal:
./manager/scanner.py:    def analyze_market(self, price_data: Dict, volume_data: Dict) -> Dict:
./manager/scanner.py:    def _calculate_volatility(self, price_data: Dict) -> Decimal:
./manager/scanner.py:    def _classify_volatility(self, volatility: float) -> str:
./manager/scanner.py:    def _calculate_trend(self, price_data: Dict) -> Decimal:
./manager/scanner.py:    def _classify_trend(self, trend_strength: float) -> str:
./manager/scanner.py:    def _calculate_liquidity(self, order_book_data: Dict) -> Decimal:
./manager/scanner.py:    def _classify_liquidity(self, liquidity: float) -> str:
./manager/scanner.py:    def _analyze_spreads(self, price_data: Dict) -> str:
./manager/scanner.py:    def _analyze_sentiment(self, price_data: Dict, volume_data: Dict) -> str:
./manager/scanner.py:    def get_trading_parameters(self) -> Dict:
./manager/staking.py:    def __init__(self, exchanges, config):
./manager/staking.py:    def _fetch_aprs(self):
./manager/staking.py:    def stake(self, coin, amount: Decimal):
./manager/staking.py:    def get_highest_apy_coin(self) -> str:
./manager/staking.py:    def unstake(self, coin, amount: Decimal = None):
./manager/persistence.py:    def __init__(self, db_path: str = "logs/quant_bot.db"):
./manager/persistence.py:    def _get_connection(self):
./manager/persistence.py:    def _init_db(self):
./manager/persistence.py:    def save_trade(self, trade_data: Dict[str, Any]):
./manager/persistence.py:    def update_portfolio_state(self, portfolio: Any, current_mode: str):
./manager/persistence.py:    def save_market_snapshot(self, exchange: str, symbol: str, bid: Decimal, ask: Decimal):
./manager/persistence.py:    def get_market_snapshots(self) -> List[Dict[str, Any]]:
./manager/persistence.py:    def save_command(self, command: str, params: Dict = None):
./manager/persistence.py:    def get_pending_commands(self) -> List[Dict[str, Any]]:
./manager/persistence.py:    def mark_command_complete(self, command_id: int):
./manager/persistence.py:    def save_position(self, coin: str, pos_data: Dict[str, Any]):
./manager/persistence.py:    def remove_position(self, coin: str):
./manager/persistence.py:    def load_last_state(self) -> Optional[Dict[str, Any]]:
./manager/persistence.py:    def load_active_positions(self) -> Dict[str, Any]:
./manager/persistence.py:    def get_sweeps_count(self, month_str: str) -> int:
./manager/persistence.py:    def get_recent_trades(self, limit: int = 50) -> List[Dict[str, Any]]:
./manager/persistence.py:    def get_all_pnl(self) -> List[Decimal]:
./manager/registry.py:    def __init__(self):
./manager/registry.py:    def update_book(self, exchange: str, symbol: str, book: Dict[str, Any]):
./manager/registry.py:    def get_order_book(self, exchange: str, symbol: str) -> Optional[Dict[str, Any]]:
./manager/registry.py:    def update_assets(self, exchange: str, data: Dict[str, Any]):
./manager/registry.py:    def update_markets(self, exchange: str, data: Dict[str, Any]):
./manager/registry.py:    def update_address(self, exchange: str, asset: str, address: str):
./manager/registry.py:    def get_fee(self, exchange: str, asset: str, network: str) -> Optional[Decimal]:
./manager/registry.py:    def get_address(self, exchange: str, asset: str) -> Optional[str]:
./manager/registry.py:    def is_network_online(self, exchange: str, asset: str, network: str) -> bool:
./manager/registry.py:    def get_all_supported_symbols(self, exchange: str) -> List[str]:
./manager/registry.py:    def get_all_stakable_assets(self, exchange: str) -> List[str]:
./manager/registry.py:    def __init__(self, registry: MarketRegistry, exchanges: Dict[str, Any]):
./manager/registry.py:    async def start(self):
./manager/registry.py:    async def sync_all(self):
./manager/registry.py:    def stop(self):
./manager/conversion.py:    def __init__(self, config: Dict = None, exchanges: Dict = None):
./manager/conversion.py:    def detect_triangle(self, books: Dict, specified_pairs: List = None, exchanges: List = None, min_prof: Decimal = None) -> List[Dict]:
./manager/conversion.py:    def _fetch_pairs(self) -> List[str]:
./manager/conversion.py:    def control_drift(self, drift_data: List[tuple], books: Dict = None) -> bool:
./manager/conversion.py:    def update_capital_mode(self, drift_data: List[tuple], total_stablecoins: Decimal, bottleneck_threshold: Decimal = Decimal('1500')):
./manager/conversion.py:    def get_best_conversion_route(self, from_asset: str, to_asset: str, exchange: str, books: Dict) -> Optional[Dict]:
./manager/money.py:    def __init__(self, config_path='config/settings.json', exchanges: Dict = None, staking_manager=None, signals_manager=None, mode_manager=None, market_registry=None, portfolio=None):
./manager/money.py:    def _load_config(self):
./manager/money.py:    def generate_macro_plan(self, price_data, min_btc_reserve, min_stable_reserve):
./manager/money.py:    def _fetch_balances(self) -> Dict:
./manager/money.py:    def _get_btc_value_for_exchange(self, exchange_name, btc_amount, price_data):
./manager/fee.py:    def __init__(self, config: dict, exchanges: Dict, registry: MarketRegistry = None):
./manager/fee.py:    def _fetch_fee_structures(self):
./manager/fee.py:    def calculate_optimal_route(self, symbol: Symbol, amount_usd: Decimal) -> tuple[str, str, Decimal]:
./manager/fee.py:    def get_effective_fee(self, exchange: str, amount_usd: Decimal, is_maker: bool) -> Decimal:
./manager/fee.py:    def _estimate_profit_after_fees(self, symbol: Symbol, amount_usd: Decimal, buy_ex: str, sell_ex: str) -> Decimal:
./manager/mode.py:    def __init__(self, portfolio: Any, tradingview_webhook_secret: str):
./manager/mode.py:    async def handle_tradingview_signal(self, signal_data: dict) -> bool:
./manager/mode.py:    def _can_switch_macro(self) -> bool:
./manager/mode.py:    def _verify_signature(self, signal_data: dict) -> bool:
./manager/mode.py:    async def _calculate_gold_conversion_target(self):
./manager/mode.py:    def get_current_mode(self) -> TradingMode:
./manager/mode.py:    def should_accumulate_gold(self) -> bool:
./manager/transfer.py:    def __init__(self, exchanges, stable, auto, registry: MarketRegistry = None):
./manager/transfer.py:    def _fetch_supported_nets(self):
./manager/transfer.py:    def balance_accounts(self):
./manager/transfer.py:    def get_best_net(self, from_name, to_name, amount: Decimal):
./manager/transfer.py:    def get_transfer_fee(self, from_name, to_name):
./manager/transfer.py:    def transfer(self, asset, from_name, to_name, amount: Decimal):
./manager/risk.py:    def __init__(self, portfolio: Portfolio, config: Dict = None):
./manager/risk.py:    def can_execute_arbitrage(self, opportunity: ArbitrageOpportunity) -> Tuple[bool, str]:
./manager/risk.py:    def check_emergency_exit(self, symbol: str, current_price: Decimal, buy_price: Decimal, allotted_capital: Decimal) -> bool:
./manager/risk.py:    def get_max_position_size(self, tpv: Decimal) -> Decimal:
./bot/A.py:    def __init__(self, config: dict, exchanges: Dict, staking_manager=None, fee_manager=None, market_registry=None, portfolio=None, persistence_manager=None):
./bot/A.py:    def slot_size_usd(self) -> Decimal:
./bot/A.py:    def _fetch_allowed_coins(self):
./bot/A.py:    def _fetch_default_stake_coin(self):
./bot/A.py:    def get_empty_slots(self) -> int:
./bot/A.py:    def handle_signal(self, action: str, coin: str, data: dict = None) -> bool:
./bot/A.py:    def _execute_buy(self, coin: str) -> bool:
./bot/A.py:    def _execute_sell(self, coin: str) -> bool:
./bot/A.py:    def _find_best_buy_price(self, coin: str) -> tuple:
./bot/A.py:    def check_seat_warmers(self) -> None:
./bot/A.py:    def _add_seat_warmer(self) -> bool:
./bot/A.py:    def _remove_oldest_seat_warmer(self) -> bool:
./bot/A.py:    def stake_idle_funds(self) -> None:
./bot/A.py:    def liquidate_all(self) -> None:
./bot/A.py:    def get_status(self) -> Dict:
./bot/G.py:    def __init__(self, config: dict, exchanges: Dict, fee_manager=None, market_registry=None, portfolio=None, persistence_manager=None):
./bot/G.py:    def _load_state(self):
./bot/G.py:    def _save_state(self):
./bot/G.py:    def _check_month_reset(self):
./bot/G.py:    def accumulate_paxg(self, amount_usd: Decimal) -> bool:
./bot/G.py:    def handle_mode_flip_to_btc(self) -> Decimal:
./bot/G.py:    def calculate_sweep_amount(self, total_gold_profit_usd: Decimal) -> Dict:
./bot/G.py:    def execute_manual_sweep(self, total_gold_profit_usd: Decimal) -> bool:
./bot/G.py:    def _find_best_paxg_price(self) -> tuple:
./bot/G.py:    def get_status(self) -> Dict:
./bot/Q.py:    def __init__(self, config: dict, exchanges: Dict, fee_manager=None, risk_manager=None, health_monitor=None, market_registry=None, portfolio=None, persistence_manager=None):
./bot/Q.py:    def max_trade_usd(self) -> Decimal:
./bot/Q.py:    def _fetch_pairs(self):
./bot/Q.py:    def get_profit_threshold(self, pair: str = None, exchange: str = None) -> Decimal:
./bot/Q.py:    def get_effective_fee(self, exchange: str, trade_value: Decimal) -> Decimal:
./bot/Q.py:    async def scan_cross_exchange(self, allocated_capital: Dict[str, Decimal]) -> List[Dict]:
./bot/Q.py:    async def scan_triangular(self, exchange_name: str, capital: Decimal) -> List[Dict]:
./bot/Q.py:    async def execute_cross_exchange(self, opportunity: Dict) -> bool:
./bot/Q.py:    async def execute_triangular(self, opportunity: Dict) -> bool:
./bot/Q.py:    def get_status(self) -> Dict:
./.git/hooks/pre-rebase.sample:                                 undef $msg;
./main.py:    def __init__(self):
./main.py:    def _load_config(self) -> Dict[str, Any]:
./main.py:    async def initialize(self):
./main.py:    async def _handle_alert(self, level: str, message: str):
./main.py:    async def handle_mode_change(self, mode_str: str):
./main.py:    def handle_abot_signal(self, action: str, coin: str, data: Dict):
./main.py:    async def update_bot_states(self):
./main.py:    async def run(self):
./main.py:    async def _bot_loop(self):
./main.py:    async def shutdown(self):
./domain/values.py:    def __str__(self):
./domain/values.py:    def __post_init__(self):
./domain/values.py:    def spread_to(self, other: 'Price') -> Decimal:
./domain/values.py:    def get_effective_fee(self, use_bnb: bool = False) -> Decimal:
./domain/values.py:    def normalize_amount(self, desired_amount: Decimal) -> Decimal:
./domain/values.py:    def is_valid_size(self, amount_usd: Decimal) -> bool:
./domain/aggregates.py:    def restore_from_dict(self, data: dict):
./domain/aggregates.py:    def update_macro_signal(self, signal: MacroSignal) -> bool:
./domain/aggregates.py:    def _can_switch_macro(self) -> bool:
./domain/aggregates.py:    def record_arbitrage_profit(self, profit_usd: Decimal):
./domain/aggregates.py:    def get_win_rate(self) -> Decimal:
./domain/aggregates.py:    def get_sharpe_ratio(self, pnl_history: List[Decimal] = None) -> Decimal:
./domain/aggregates.py:    def should_convert_to_gold(self) -> bool:
./domain/aggregates.py:    def is_alive(self, timeout_seconds: int = 60) -> bool:
./domain/entities.py:    def symbol(self) -> str:
./domain/entities.py:    def __str__(self):
./domain/entities.py:    def available_for_trading(self) -> Decimal:
./domain/entities.py:    def is_filled(self) -> bool:
./domain/entities.py:    def remaining(self) -> Decimal:
./domain/entities.py:    def is_profitable(self) -> bool:
./domain/entities.py:    def profit_after_fees(self) -> Decimal:
./domain/entities.py:    def is_valid(self) -> bool:
./domain/entities.py:    def can_take_position(self, position_usd: Decimal) -> bool:
./domain/entities.py:    def get_effective_fee(self, is_maker: bool = False, use_bnb: bool = False) -> Decimal:
